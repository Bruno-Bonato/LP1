4a) No exercício 2, ao declararmos uma struct Personagem pX, atribuímos a ela a função preencherA(), sem nenhum parâmetro. A função retorna uma struct Personagem temporária já preenchida. Dessa forma, ao atribuirmos a struct Personagem pX o valor retornado pela função, a struct temporária atualiza pX globalmente. Por outro lado, no exercício 3, passamos como parâmetro o endereço de pX (&pX). Assim, dentro da função, preencherB recebe um ponteiro para uma struct Personagem. Por meio desse ponteiro, que aponta diretamente para pX, são atribuídos valores a cada campo. Portanto, usando ponteiros, preencherB altera os valores de pX globalmente, sem a necessidade de uma struct temporária nem de realizar uma cópia.

b) Utilizando ponteiros, o processo é mais fácil e rápido; porém, eu prefiro utilizar uma struct temporária, pois não me sinto confortável trabalhando com ponteiros. Quando usamos ponteiros, é necessário ter atenção redobrada para não confundir as ações de cada operador.

c) Ao utilizarmos ponteiros, ou seja, a função preencherB, não precisamos reservar espaço adicional para o retorno da função, pois ela é declarada como tipo void. Isso difere da função preencherA, que declara um tipo struct Personagem. Além disso, como não usamos uma struct temporária, economizamos espaço de memória para mais uma struct. Como operamos diretamente sobre a struct original, não realizamos operações de atribuição entre a struct e o retorno da função, tornando o processo mais rápido e usando menos memória.